#!/usr/bin/env python
'''
PALIN toolbox v0.1
December 2022, Aynaz Adl Zarrabi, JJ Aucouturier (CNRS/UBFC)

Functions for kernel calculating method in Classification images
'''

import pandas as pd
import numpy as np
import os.path
import warnings
import ast
from .internal_noise_extractor import InternalNoiseExtractor
from abc import ABC,abstractmethod

class AgreementMethod(InternalNoiseExtractor):
    ''' 
    This abstract class subserves all InternalNoiseExtractors that rely on simulating ideal observers with a range of internal noise and criteria values to match an observed measure of probability of agreement
    The class implements the simulation method, but does not implement methods to compute prob_agreement and prob_first. 
    Options to do that are in child classes DoublePass (which relies on the availability of exactly repeated trials, aka 'Ponsot/Neri' method), InterceptMethod (which estimates agreement based on closely resembling trials) and others
    '''

    def __str__(self): 
        return 'Agreement method'

    @classmethod
    def extract_single_internal_noise(cls,data_df, trial_id, stim_id, feature_id, value_id, response_id, model_file, rebuild_model=False, internal_noise_range=np.arange(0,5,.1),criteria_range=np.arange(-5,5,1), n_repeated_trials=100, n_runs=10):
        '''
        Extracts internal noise and criteria for a single observer/session. 
        To extract for several users/sessions, use the superclass's method extract_internal_noise
        '''
        prob_agree, prob_first = cls.compute_probabilities(data_df, trial_id, stim_id, feature_id, value_id, response_id)

        internal_noise, criteria = cls.estimate_noise_criteria(prob_agree, prob_first, model_file, rebuild_model, internal_noise_range,criteria_range, n_repeated_trials, n_runs)

        return internal_noise,criteria

    @classmethod
    def compute_probabilities(cls,data_df, trial_id, stim_id, feature_id, value_id, response_id,kernel_extractor=None):
        # compute probability of agreement, using the intercept method over all trials (regardless of double pass)
        prob_agree = cls.compute_prob_agreement(data_df, trial_id=trial_id, stim_id= stim_id, feature_id= feature_id, value_id= value_id, response_id=response_id, kernel_extractor=kernel_extractor)
        # compute probability of choosing first response option over all trials (regardless of double pass)
        prob_first = cls.compute_prob_first(data_df, trial_id=trial_id, response_id=response_id, stim_id=stim_id)
        return prob_agree, prob_first
        
    @classmethod
    @abstractmethod
    def compute_prob_agreement(cls,data_df, trial_id='trial', stim_id= 'stim', feature_id= 'segment', value_id = 'value', response_id='response', kernel_extractor=None):
        raise NotImplementedError()

    @classmethod
    @abstractmethod
    def compute_prob_first(cls, data_df, trial_id='trial', response_id='response', stim_id='stim_order'):
        raise NotImplementedError()
    
    @classmethod
    def estimate_noise_criteria(cls,prob_agree, prob_first, model_file,rebuild_model=False, internal_noise_range=np.arange(0,5,.1),criteria_range=np.arange(-5,5,1), n_repeated_trials=100, n_runs=10): 
        '''
        Estimates internal noise and criteria given a measure of prob_agree and prob_first. 
        Either uses a prebuilt model (a dataframe previously generated by @build_model and stored as a .csv file), or rebuild a new model. 
        Searches through a range of possible internal noise and criteria values
        '''    
        # load model or rebuild
        if os.path.isfile(model_file) & ~rebuild_model: 
            model_df = pd.read_csv(model_file, index_col=0)
        else:
            model_df = cls.build_model(internal_noise_range, criteria_range, n_repeated_trials, n_runs)
            model_df.to_csv(model_file)

        # find internal_noise & criteria settings that minimizes distance to prob_agree and prob_first 
        model_df['dist'] = model_df.apply(lambda row: (row.prob_agree-prob_agree)**2 + (row.prob_first-prob_first)**2, axis=1)

        best_match = model_df[model_df.dist==model_df.dist.min()]

        return best_match.internal_noise_std.iloc[0], best_match.criteria.iloc[0]

    @classmethod
    def build_model(cls,internal_noise_range=np.arange(0,5,.1),criteria_range=np.arange(-5,5,1), n_repeated_trials=100, n_runs=10): 
        '''
        Build a model that associates a range of internal noise and criteria values with their corresponding (simulated) prob_agree and prob_first.
        This uses a simulated LinearObserver, and returns the model as a dataframe 
        '''
        print('Rebuilding double-pass model')

        # deferred imports of the simulation modules, to avoid circular imports
        from ..simulation.observers.linear_observer import LinearObserver
        from ..simulation.trial import Int2Trial 
        from ..simulation.experiments.double_pass_experiment import DoublePassExperiment
        from ..simulation.trial import Int2Trial, Int1Trial 
        from ..simulation.analysers.double_pass_statistics import DouplePassStatistics
        from ..simulation.simulation import Simulation as Sim

        observer_params = {'kernel':[[1]],
                   'internal_noise_std':internal_noise_range, 
                  'criteria':criteria_range}
        experiment_params = {'n_trials':[n_repeated_trials],
                     'n_repeated':[n_repeated_trials],
                     'trial_type': [Int2Trial],
                     'n_features': [1],
                     'external_noise_std': [1]}
        analyser_params = {}

        sim = Sim(DoublePassExperiment, experiment_params,
              LinearObserver, observer_params, 
              DoublePassStatistics, analyser_params)

        sim_df = sim.run_all(n_runs=n_runs, verbose=True)

        # average measures over all runs
        sim_df.groupby(['internal_noise_std','criteria'])[DoublePassStatistics.get_metric_names()].mean()
        return sim_df

       